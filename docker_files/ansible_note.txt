ansible_notes:
--------------
Creating the variables:
-------------------------
variables: means it stores the data vales in avriables
Data Types:
1.int(x: 34)
foat(x: 34.456)
string(myname: "radhakrishna", my_name; radhakrishna)
bool( x: true, y:false, z: True, p: False, q: yes, q: no)
------------
---> Ansible data structures and data collection:
Data sructre or dtat collections:
--> are used to store multiple data/values.
1.scalar
2.sequence or list[]
3.dictionay or mappping
--> i want to install multiple pkgs:
example:
---
 - hosts: all 
   vars:
    x: 345
    pakgs: ['vim', 'nano', 'nginx'] #list
    web_server: {'linux', 'apache2', 'ubuntu'} #web_server is variable and it is dictionary  or mapping 
    
    format
   tasks:
   - debug: var=pakgs
   - debug: var=web_server 
--------------------------------------------------
By  using register and set_facts to find out the bash in linux mchine :

Register:
by using the register key to store the values: by executing the tasks
ex: tasks:
   - shell: "bash --version"
   #to store the varianble in registre keys:
and then assing the value to store used thr register key: ex: 

  register: bash_var #here to store the value in register key is bash_var
  #but it not showing the output,
   Debug moduleis used to print the output: in that case used the debug module to printout output
   - debug: var=bash_var    
==========================================
--
 - hosts: all
   gather_facts: no
   tasks:
   - shell: "bash --version"
   #to store the varianble in registre keys:
     register: bash_var #here to store the value in register key is bash_var
  #but it not showing the output,in that case used the debug module to printout output
   - debug: var=bash_var.stdout.split("\n")[0].split()
   # here using the python split module for required outputs using split('\n')[0](#indexnumber).split() for space

#here always write a  long sytax like var=bash_var.stdout.split("\n")[0].split() 
#insted fo these one create the variablea ans store the variable value into it. by using set fact
==================================================================
set_fact module is used to define a new variables
---
 - hosts: all
   gather_facts: no
   tasks:
   - shell: "bash --version"
   #to store the varianble in registre keys:
     register: bash_var #here to store the value in register key is bash_var
   #here always write a  long sytax like var=bash_var.stdout.split("\n")[0].split() 
#insted fo these one create the variablea ans store the variable value into it. by using set fact
#set_facts: used for making simple variables
  - set_facts:
      bash_version: {bash_var.stdout.split("\n")[0].split()[3]} 
  
  #but it not showing the output,in that case used the debug module 
  to printout output
  # here using the python split module for required outputs using split('\n')[0](#indexnumber).split() for space

   - debug: var=bash_version
   -----------------------------
   How to read and print variable using ansible playbooks?
   Ans by using vars module and debug for print variable.
   example:

  ---
 - hosts: all
   vars:
    x: 23456
    name: "krishnaradha"
   tasks:
   - debug:
      msg:
       - "the variable vale is {{x}}"
       - "the name of the student is {{name}}"   
===============================================
Dynamic allocation of variable to read the variable values whie running a process by using vars_prompt
example: 
--
 - hosts: all
   vars:
    x: 23456
    name: "krishnaradha"
   vars_prompt:
    name: y
    prompt: Enter the value for y
    private: false
   tasks:
   - debug:
      msg:
       - "the variable vale is {{x}}"
       - "the name of the student is {{name}}"   
       - "the var is value is {{y}}"
-----------------------------------------------------
example: foe suppose i want to enter the values fo user name ans password while running the ansible-playbooks.
Here the var_prompt is important 
and prompt key word is importnant to display runtime 

---
 - hosts: all
   vars_prompt:
    - name: user_name
      prompt: Enter Username 
      private: false
    - name: password
      prompt: Enter the password
      private: yes
   tasks:
   - debug:
      msg: "THe username is: {{user_name}} and the password is: {{password}}"
 ------------------------------
 how to reading variables from file

 Types of files:
 1.Ymal files
 2.JSON files

 =>read variables from multiple files
 ex:
 for example one json data file and ymail file 
1.the json data file and ymal file to read the ansible playbooks by using the module vars_files : filenames
example: json data file
{
  "a": 976,
  "b": [1,2,3,4,"krishns","radha"],
  "c": {"radha":1,"krishna":2,"rama":4,"j":"radhakrishna"}
}     
Ansible playbook

---
 - hosts: all
   vars_files: 
   - var_value.yml
   - var.json
   tasks:
    - debug: var=c
#here the c is the variable to read the data to stored the values in json.
by uisng debug module(print)--> var-> variable call the particular variable data
------------------------------------------------------
Working with command line arguments:
The variables can be define by different ways:
1.vars 2.vars_prompt 3.vars_files.
Differnt tpes of passed the arguments:
1,scalar 2,sequnce(list) 3,map(dict) 4.files with variables

By using diifent  procedures:

Example; 1.ansible-playbooks cmd_line.yml -e "x=2345" #shortcut 
2. ansible-playbooks cmd_line.yml --extra-var x=123 
3. ansible-playbooks cmd_line.yml -e "{'x'=2344,'y'=987864}"
nsible-playbooks cmd_line.yml -e "x='radhakrishna'"

Multiple varaible from command lines:
ansible-playbooks cmd_line.yml -e "{'x': 234, 'y': 34}"

Sequnce values:(list)
ansible-playbooks cm.yml -e "{'x': [1,3,'radha',8,90,'krishna'}"
 
 map:(dict):
ansible-playbooks cm.yml -e "{'x': 'krishna', 'one': 1}"
===========================
By command line to pass the variable values :
example to install the pkg like nginx and apache2 servers by uing command line arguments passing methed

reading_vars.yml
| | |
---

---
 - name: This is a sample playbooks to undestand the command line arguments
   hosts: web
   gather_facts: false
  # become: yes
   tasks:
   - name: Install and working with  {{pkg}} (state=present is optional)
     apt:
       name: "{{pkg}}"
       state: {{req_state}}"

================================
comnad: ansible-playbooks  reading_vars.yml -e "pkg=nginx req_state=present"sing 

Working with gather facts variable or setup varmodule
 Using of gatherfacs ,how tocollect information about remote hosts with gatherfacts
 examples;
 
 ---
 - name: Finding the os name and distribution
   hosts: all
   gather_facts: no
   tasks:
   - name: finding the os distribution
     shell: cat /etc/os-release | awk -F 'NR==1 {print $2 }' | awk '{print $1}' | tr '\"' ' '"
     register: os_dist
   - name: Finding the os name
     shell: "uname"
     register: os_name
   - debug:
      msg:
       - "The os distribution name is : {{os_dist}}"
       - "The os name is : {{os_name}}"    
----------------------------------------------
Arthmetic operations:
 Arthmetics opetarion can be done by using Ansible with Jinja syntax.
Example:
 ---
 - name: Arthematic operations examples
   hosts: all 
   gather_facts: false 
   vars_prompt:
    - name: a 
      prompt: Enetr the a values 
      private: no 
    - name: b 
      prompt: Enter the b values 
      private: no
   tasks:
   - debug: 
        msg:   
        - 'The vale of a is : {{a}}'
        - 'The value of b is : {{b}}'
        - 'The addition of {{a}} and {{b}} is {{a|int+b|int}}' # Integet value only assing 
        - 'The addition of {{a}} and {{b}} is {{a|int*b|int}}'
 
--------------------------------------------------------
Filters and methods in ansible playbooks:
1.filters and methods are the operational of ansible,
2.Ansible inbuilt filteres(Jinja filters)
Note: if you find your required opetations use python methods
3.Python methods
4.Use | --> this pipeline symbol for inbuilt /jinja2 filters
5.Use . --> For python methods

Example: 
---
 - hosts: all 
   gather_facts: false 
   vars:
    x: 'This is about filters and methods'
    y: '56'
    z: [2344,5444,5543344,555566555,9908.9,9,89,67]
   tasks:
   - debug:
       msg:
         - "{{x|lower}}" #lower filter is used for lower letters
         - "{{x|upper}}"
         - "{{x|title}}"#jinja syntax
         - "{{x.lower()}}"#python methods
         - "{{y.int()}}" #python y value is intiall string and it converted in to interger by using y.int()
         - "the max value of z is : {{z.max()}}"
         -"The min value of z is: {{z.min()}}"
-------------------------------------------------------------
 - hosts: nodes
   gather_facts: false
   vars:
    z: [2344,5444,5543344,555566555,9908.9,9,89,67]
    y: 100
   tasks:
    - debug:
        msg:
         - "{{z |random}}"
         - "{z |random}} * * * * root /script/from/cron"
         - "{{y |random(step=20) }}"
================================================================> Ansible filetrs list:

Filters For Formatting Data
The following filters will take a data structure in a template and render it in a slightly different format. These are occasionally useful for debugging:

{{ some_variable | to_json }}
{{ some_variable | to_yaml }}

For human readable output, you can use:

{{ some_variable | to_nice_json }}
{{ some_variable | to_nice_yaml }}

It’s also possible to change the indentation of both (new in version 2.2):

{{ some_variable | to_nice_json(indent=2) }}
{{ some_variable | to_nice_yaml(indent=8) }}

Alternatively, you may be reading in some already formatted data:

{{ some_variable | from_json }}
{{ some_variable | from_yaml }}

for example:

tasks:
  - shell: cat /some/path/to/file.json
    register: result

  - set_fact: myvar="{{ result.stdout | from_json }}"

Forcing Variables To Be Defined
The default behavior from ansible and ansible.cfg is to fail if variables are undefined, but you can turn this off.

This allows an explicit check with this feature off:

{{ variable | mandatory }}

The variable value will be used as is, but the template evaluation will raise an error if it is undefined.

Defaulting Undefined Variables
Jinja2 provides a useful ‘default’ filter, that is often a better approach to failing if a variable is not defined:

{{ some_variable | default(5) }}
In the above example, if the variable ‘some_variable’ is not defined, the value used will be 5, rather than an error being raised.

Omitting Parameters
As of Ansible 1.8, it is possible to use the default filter to omit module parameters using the special omit variable:

- name: touch files with an optional mode
  file: dest={{item.path}} state=touch mode={{item.mode|default(omit)}}
  with_items:
    - path: /tmp/foo
    - path: /tmp/bar
    - path: /tmp/baz
      mode: "0444"

For the first two files in the list, the default mode will be determined by the umask of the system as the mode= parameter will not be sent to the file module while the final file will receive the mode=0444 option.

Note

If you are “chaining” additional filters after the default(omit) filter, you should instead do something like this: “{{ foo | default(None) | some_filter or omit }}”. In this example, the default None (python null) value will cause the later filters to fail, which will trigger the or omit portion of the logic. Using omit in this manner is very specific to the later filters you’re chaining though, so be prepared for some trial and error if you do this.

List Filters
These filters all operate on list variables.

New in version 1.8.

To get the minimum value from list of numbers:

{{ list1 | min }}

To get the maximum value from a list of numbers:

{{ [3, 4, 2] | max }}

Set Theory Filters
All these functions return a unique set from sets or lists.

New in version 1.4.

To get a unique set from a list:

{{ list1 | unique }}

To get a union of two lists:

{{ list1 | union(list2) }}

To get the intersection of 2 lists (unique list of all items in both):

{{ list1 | intersect(list2) }}

To get the difference of 2 lists (items in 1 that don’t exist in 2):

{{ list1 | difference(list2) }}

To get the symmetric difference of 2 lists (items exclusive to each list):

{{ list1 | symmetric_difference(list2) }}

Random Number Filter
New in version 1.6.

This filter can be used similar to the default jinja2 random filter (returning a random item from a sequence of items), but can also generate a random number based on a range.

To get a random item from a list:

"{{ ['a','b','c']|random }}"
# => 'c'
To get a random number from 0 to supplied end:

"{{ 59 |random}} * * * * root /script/from/cron"
# => '21 * * * * root /script/from/cron'
Get a random number from 0 to 100 but in steps of 10:

{{ 100 |random(step=10) }}
# => 70
Get a random number from 1 to 100 but in steps of 10:

{{ 100 |random(1, 10) }}
# => 31
{{ 100 |random(start=1, step=10) }}
# => 51
As of Ansible version 2.3, it’s also possible to initialize the random number generator from a seed. This way, you can create random-but-idempotent numbers:

"{{ 59 |random(seed=inventory_hostname) }} * * * * root /script/from/cron"
Shuffle Filter
New in version 1.8.

This filter will randomize an existing list, giving a different order every invocation.

To get a random list from an existing list:

{{ ['a','b','c']|shuffle }}
# => ['c','a','b']
{{ ['a','b','c']|shuffle }}
# => ['b','c','a']
As of Ansible version 2.3, it’s also possible to shuffle a list idempotent. All you need is a seed.:

{{ ['a','b','c']|shuffle(seed=inventory_hostname) }}
# => ['b','a','c']
note that when used with a non ‘listable’ item it is a noop, otherwise it always returns a list

Math
New in version 1.9.

Get the logarithm (default is e):

{{ myvar | log }}
Get the base 10 logarithm:

{{ myvar | log(10) }}
Give me the power of 2! (or 5):

{{ myvar | pow(2) }}
{{ myvar | pow(5) }}
Square root, or the 5th:

{{ myvar | root }}
{{ myvar | root(5) }}
Note that jinja2 already provides some like abs() and round().

JSON Query Filter
New in version 2.2.

Sometimes you end up with a complex data structure in JSON format and you need to extract only a small set of data within it. The json_query filter lets you query a complex JSON structure and iterate over it using a with_items structure.

Note

This filter is built upon jmespath, and you can use the same syntax. For examples, see jmespath examples.

Now, let’s take the following data structure:

domain_definition:
    domain:
        cluster:
            - name: "cluster1"
            - name: "cluster2"
        server:
            - name: "server11"
              cluster: "cluster1"
              port: "8080"
            - name: "server12"
              cluster: "cluster1"
              port: "8090"
            - name: "server21"
              cluster: "cluster2"
              port: "9080"
            - name: "server22"
              cluster: "cluster2"
              port: "9090"
        library:
            - name: "lib1"
              target: "cluster1"
            - name: "lib2"
              target: "cluster2"
To extract all clusters from this structure, you can use the following query:

- name: "Display all cluster names"
  debug: var=item
  with_items: "{{domain_definition|json_query('domain.cluster[*].name')}}"
Same thing for all server names:

- name: "Display all server names"
  debug: var=item
  with_items: "{{domain_definition|json_query('domain.server[*].name')}}"
This example shows ports from cluster1:

- name: "Display all server names from cluster1"
  debug: var=item
  with_items: "{{domain_definition|json_query(server_name_cluster1_query)}}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster1'].port"
Note

You can use a variable to make the query more readable.

In this example, we get a hash map with all ports and names of a cluster:

- name: "Display all server ports and names from cluster1"
  debug: var=item
  with_items: "{{domain_definition|json_query(server_name_cluster1_query)}}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster2'].{name: name, port: port}"
IP address filter
New in version 1.9.

To test if a string is a valid IP address:

{{ myvar | ipaddr }}
You can also require a specific IP protocol version:

{{ myvar | ipv4 }}
{{ myvar | ipv6 }}
IP address filter can also be used to extract specific information from an IP address. For example, to get the IP address itself from a CIDR, you can use:

{{ '192.0.2.1/24' | ipaddr('address') }}
More information about ipaddr filter and complete usage guide can be found in ipaddr filter.

Hashing filters
New in version 1.9.

To get the sha1 hash of a string:

{{ 'test1'|hash('sha1') }}
To get the md5 hash of a string:

{{ 'test1'|hash('md5') }}
Get a string checksum:

{{ 'test2'|checksum }}
Other hashes (platform dependent):

{{ 'test2'|hash('blowfish') }}
To get a sha512 password hash (random salt):

{{ 'passwordsaresecret'|password_hash('sha512') }}
To get a sha256 password hash with a specific salt:

{{ 'secretpassword'|password_hash('sha256', 'mysecretsalt') }}
Hash types available depend on the master system running ansible, ‘hash’ depends on hashlib password_hash depends on crypt.

Combining hashes/dictionaries
New in version 2.0.

The combine filter allows hashes to be merged. For example, the following would override keys in one hash:

{{ {'a':1, 'b':2}|combine({'b':3}) }}
The resulting hash would be:

{'a':1, 'b':3}
The filter also accepts an optional recursive=True parameter to not only override keys in the first hash, but also recurse into nested hashes and merge their keys too

{{ {'a':{'foo':1, 'bar':2}, 'b':2}|combine({'a':{'bar':3, 'baz':4}}, recursive=True) }}
This would result in:

{'a':{'foo':1, 'bar':3, 'baz':4}, 'b':2}
The filter can also take multiple arguments to merge:

{{ a|combine(b, c, d) }}
In this case, keys in d would override those in c, which would override those in b, and so on.

This behaviour does not depend on the value of the hash_behaviour setting in ansible.cfg.

Extracting values from containers
New in version 2.1.

The extract filter is used to map from a list of indices to a list of values from a container (hash or array):

{{ [0,2]|map('extract', ['x','y','z'])|list }}
{{ ['x','y']|map('extract', {'x': 42, 'y': 31})|list }}
The results of the above expressions would be:

['x', 'z']
[42, 31]
The filter can take another argument:

{{ groups['x']|map('extract', hostvars, 'ec2_ip_address')|list }}
This takes the list of hosts in group ‘x’, looks them up in hostvars, and then looks up the ec2_ip_address of the result. The final result is a list of IP addresses for the hosts in group ‘x’.

The third argument to the filter can also be a list, for a recursive lookup inside the container:

{{ ['a']|map('extract', b, ['x','y'])|list }}
This would return a list containing the value of b[‘a’][‘x’][‘y’].

Comment Filter
New in version 2.0.

The comment filter allows to decorate the text with a chosen comment style. For example the following:

{{ "Plain style (default)" | comment }}
will produce this output:

#
# Plain style (default)
#
Similar way can be applied style for C (//...), C block (/*...*/), Erlang (%...) and XML (<!--...-->):

{{ "C style" | comment('c') }}
{{ "C block style" | comment('cblock') }}
{{ "Erlang style" | comment('erlang') }}
{{ "XML style" | comment('xml') }}
It is also possible to fully customize the comment style:

{{ "Custom style" | comment('plain', prefix='#######\n#', postfix='#\n#######\n   ###\n    #') }}
That will create the following output:

#######
#
# Custom style
#
#######
   ###
    #
The filter can also be applied to any Ansible variable. For example to make the output of the ansible_managed variable more readable, we can change the definition in the ansible.cfg file to this:

[defaults]

ansible_managed = This file is managed by Ansible.%n
  template: {file}
  date: %Y-%m-%d %H:%M:%S
  user: {uid}
  host: {host}
and then use the variable with the comment filter:

{{ ansible_managed | comment }}
which will produce this output:

#
# This file is managed by Ansible.
#
# template: /home/ansible/env/dev/ansible_managed/roles/role1/templates/test.j2
# date: 2015-09-10 11:02:58
# user: ansible
# host: myhost
#
Other Useful Filters
To add quotes for shell usage:

- shell: echo {{ string_value | quote }}
To use one value on true and another on false (new in version 1.9):

{{ (name == "John") | ternary('Mr','Ms') }}
To concatenate a list into a string:

{{ list | join(" ") }}
To get the last name of a file path, like ‘foo.txt’ out of ‘/etc/asdf/foo.txt’:

{{ path | basename }}
To get the last name of a windows style file path (new in version 2.0):

{{ path | win_basename }}
To separate the windows drive letter from the rest of a file path (new in version 2.0):

{{ path | win_splitdrive }}
To get only the windows drive letter:

{{ path | win_splitdrive | first }}
To get the rest of the path without the drive letter:

{{ path | win_splitdrive | last }}
To get the directory from a path:

{{ path | dirname }}
To get the directory from a windows path (new version 2.0):

{{ path | win_dirname }}
To expand a path containing a tilde (~) character (new in version 1.5):

{{ path | expanduser }}
To get the real path of a link (new in version 1.8):

{{ path | realpath }}
To get the relative path of a link, from a start point (new in version 1.7):

{{ path | relpath('/etc') }}
To get the root and extension of a path or filename (new in version 2.0):

# with path == 'nginx.conf' the return would be ('nginx', '.conf')
{{ path | splitext }}
To work with Base64 encoded strings:

{{ encoded | b64decode }}
{{ decoded | b64encode }}
To create a UUID from a string (new in version 1.9):

{{ hostname | to_uuid }}
To cast values as certain types, such as when you input a string as “True” from a vars_prompt and the system doesn’t know it is a boolean value:

- debug: msg=test
  when: some_string_value | bool
New in version 1.6.

To replace text in a string with regex, use the “regex_replace” filter:

# convert "ansible" to "able"
{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\1') }}

# convert "foobar" to "bar"
{{ 'foobar' | regex_replace('^f.*o(.*)$', '\\1') }}

# convert "localhost:80" to "localhost, 80" using named groups
{{ 'localhost:80' | regex_replace('^(?P<host>.+):(?P<port>\\d+)$', '\\g<host>, \\g<port>') }}

# convert "localhost:80" to "localhost"
{{ 'localhost:80' | regex_replace(':80') }}
Note

Prior to ansible 2.0, if “regex_replace” filter was used with variables inside YAML arguments (as opposed to simpler ‘key=value’ arguments), then you needed to escape backreferences (e.g. \\1) with 4 backslashes (\\\\) instead of 2 (\\).

New in version 2.0.

To escape special characters within a regex, use the “regex_escape” filter:

# convert '^f.*o(.*)$' to '\^f\.\*o\(\.\*\)\$'
{{ '^f.*o(.*)$' | regex_escape() }}
To make use of one attribute from each item in a list of complex variables, use the “map” filter (see the Jinja2 map() docs for more):

# get a comma-separated list of the mount points (e.g. "/,/mnt/stuff") on a host
{{ ansible_mounts|map(attribute='mount')|join(',') }}
To get date object from string use the to_datetime filter, (new in version in 2.2):

# get amount of seconds between two dates, default date format is %Y-%d-%m %H:%M:%S but you can pass your own one
{{ (("2016-08-04 20:00:12"|to_datetime) - ("2015-10-06"|to_datetime('%Y-%d-%m'))).seconds  }}
Combination Filters
New in version 2.3.

This set of filters returns a list of combined lists. To get permutations of a list:

- name: give me largest permutations (order matters)
  debug: msg="{{ [1,2,3,4,5]|permutations|list }}"

- name: give me permutations of sets of 3
  debug: msg="{{ [1,2,3,4,5]|permutations(3)|list }}"
Combinations always require a set size:

- name: give me combinations for sets of 2
  debug: msg="{{ [1,2,3,4,5]|combinations(2)|list }}"
To get a list combining the elements of other lists use zip:

- name: give me list combo of 2 lists
  debug: msg="{{ [1,2,3,4,5]|zip(['a','b','c','d','e','f'])|list }}"

- name: give me shortest combo of 2 lists
  debug: msg="{{ [1,2,3]|zip(['a','b','c','d','e','f'])|list }}"
To always exhaust all list use zip_longest:

- name: give me longest combo of 3 lists , fill with X
  debug: msg="{{ [1,2,3]|zip_longest(['a','b','c','d','e','f'], [21, 22, 23], fillvalue='X')|list }}"
Debugging Filters
New in version 2.3.

Use the type_debug filter to display the underlying Python type of a variable. This can be useful in debugging in situations where you may need to know the exact type of a variable:

{{ myvar | type_debug }}
A few useful filters are typically added with each new Ansible release. The development documentation shows how to extend Ansible filters by writing your own as plugins, though in general, we encourage new ones to be added to core so everyone can make use of them.
===============================================================>
example: 
---
 - hosts: nodes
   gather_facts: false
   vars:
    x: 1234433
    z: [2344,5444,5543344,555566555,9908.9,9,89,67]
    y: 100
    j: ['adi','krishna','hari',45,6.090,'j',2,'rama',0.99,'venkat]
   tasks:
    - debug:
        msg:
         - "{{z |random}}"
         - "{z |random}} * * * * root /script/from/cron"
         - "{{y |random(step=20) }}"
         - "{{z | default(89) }}"
         - "{{y |random(1, 10) }}"
         - "{{y |random(start=1, step=2) }}"
         - "{{j | shuffle }}"
         - "{{x | log }}"
         - "{{x | log(10) }}"
         - "{{x | pow(2) }}"
         - "{{x | pow(9) }}"
         - "{{x | root }}"
         - "{{x | root(5) }}"
-------------------------------------------
 - hosts: nodes 
   gather_facts: false 
   vars: 
     x: ['krishna','radha',3.4,4,566555,'j','hari',0.466]
     y: 100
     z: [2344,5444,5543344,555566555,9908.9,9,89,67]
     a: 343
   tasks:
    - debug:
       msg:
        - "{{x |random}}"
        - "{{z |random}}"
        - "{{y |random(step=2) }}"
        - "{{y |random(start=1,step=5) }}"
        - "{{x | shuffle }}"
        - "{{a | log }}"
        - "{{a | log(10) }}"
        - "{{a | pow(3) }}"
        - "{{a | pow(6) }}"
        - "{{a | root }}"
        - "{{a | root(5) }}"

--------------------------------------------------------------------------------------
comparisiion ooperators:
1,>,<,==,!=,<=,>= ....etc
1.These are very impoertnat to work with conditional operators
2.The result of compariosn operators is either tru or false .only
example: 
---
 - hosts: all
   gather_facts: fals
   vars:
     x: 6
     y: 10
   tasks: 
    - debug:
        msg: 
         - "The vale of x is {{X}} and value if y is {{y}}"   
         - "{x ==y}: {{x == y }}"
         - "{x > y}: {{x > y }}"
         - "{x != y}: {{x != y }}"
         - "{x >= y}: {{x >= y }}"
          - "{x <=y}: {{x <=y }}"
========================================================
membership and test operators of ansible playbooks
 1.in 2 not in

 example: ---
 - name: This is about membership operators
   hosts: all 
   gather_facts: false 
   vars:
     x: [3,45,6443,355,43,2,5,6,7,0] #here like this we can use like python or used jinja syntax show likes belows 
  #  x: 
   #   - 23
    #  - 43
     # - 9
     # - 87
    y: 989788
   tasks:
    - debug:
        msg:
          - 'the list of squence x is {{x}} and y value is: {{y}}'

=====================================================================
--> 
How to use conditional staements
1.when,2.failed_when,3.chnaged_when


--> contional opetations 
example;

---
 - name: Simple paly for install apache 
   hosts: nodes
   gather_facts: false
   tasks: 
      - name: Installing httpd  using YUM 
        yum:
          name: httpd
          state: latest
        when: ansible_distribution != "Ubuntu"  
      - name:
        apt:
          name: apache2 
          update_cache: yes 
          state: latest
        when: ansible_distribution == "Ubuntu"  

  ---> Inline conditional staements
when and if else conditions
============================
Handlers:
ex:
  ---
 - hosts: nodes
   gather_facts: false
   tasks: 
      - name: Installing apache2
        apt:
          name: apache2 
          state: present 
        notify: 
          - start apache2
   handlers:
      - name: start apache2 
        service: 
          name: apache2 
          state: started 


               
        #register: out 
      #- debug: var = out.changed  
      #- name: start apache2 
       # service:  
        #  name: apache2 
         # state: started
        #when: out.changed == True 
 ------------------------------------------
 -->loops
 ex: 
 ---
 - name: Usinhg loops 
   hosts: all
   gather_facts: false 
   tasks:
      - apt:
          name: '{{item}}' 
          state: present
      
     # - debug:
           #msg: 'The current pkg is: {{item}}'
        loop:
           - git 
           - java8
           - nginx 
-------------------------------------
-->working with ansible tags:

example:
# ansible-playbook tags.yml --tags first --> tags as first only executes  -t or --tags to skipped tags = --skip-tags first
#Never use for don't run the particular tasks,untill unless calll the particular tassks
#always executing the default tasks
---
 - hosts: all 
   gather_facts: false 
   tasks:
     - debug:
         msg: 'The is the first task'
       tags: 
         - first
         - never  
     - debug:
         msg: 'The is the second task'
       tags: 
         - second 
         - always #execute by default    
     - debug:
         msg: 'The is the third task'
       tags: third    
     - debug:
         msg: 'The is the fourth task' 
       tags: 
         - fourth 
         - never
     - debug:
         msg: 'The is the fifth task'
       tags: fifth   
     - debug:
         msg: 'The is the sixth task'       
       tags: sixth  
       ===========================================
====>Error Hnadlings

-->1. Ansible normally has defaults that makes sure to check the returns code od commands /modues and it fails retrun code non zero
---->2. Ifthe current task fails thn playbook will stop the executing the remaining tasks on the hosts by ignoring the particular task and executes next 
ignore_errors: yes

---
 ---
 - hosts: all 
   gather_facts: false 
   tasks:
      - command: 'ls /home'
        register: home_out #capture the outputs used ffor home_out--> variable
        ignore_errors: yes  
      - debug: var=home_out
      - command: 'ls /tmp'
        register: tmp_out
      - debug: var=tmp_out   #to dispaly this output
  =======================      =================== 
#Error handling with blocks and rescue in playbooks
Ans: Ansible stops playbooks to executes on the task failure ans we canchoose to ignore_errors to continue with remianing tasks.
 NOte: ansible execute a tasks ,in some cases if one task is failure, the remining tasks are not executes,
 by sovling these problem we can used the module of ignore_errors: yes 
 It will be ignore the fist task, if failure , the reminig tasks are executes.

 ignore_errors for a entier block example:

 ---
 - hosts: all 
   gather_facts: false 
   tasks:
      - block:
         - command: 'ls /home/tomcat7'
           register: tomcat7_out  
         - command: 'ls /home/tomcat8'
           register: tomcat8_out
        ignore_errors: yes 
      - debug: var=tomcat7_out  
      - debug; var=tomcat8_out
         
     ===================================




        















